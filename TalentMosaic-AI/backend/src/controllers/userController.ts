import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import db from "../config/db";  // Aseg√∫rate de que db est√© correctamente configurado
import { User } from "../models/schema"; // Aseg√∫rate de que esta ruta sea correcta
import dotenv from 'dotenv';
import { SignOptions } from 'jsonwebtoken';
import { v4 as uuidv4 } from 'uuid';


dotenv.config();

class UserController {
  // üîπ Serializaci√≥n: Convierte un objeto de la aplicaci√≥n a formato SQL
  private serialize(user: any) {
    return {
      id: user.id,
      companyId: user.companyId,
      firstName: user.firstName,
      lastName: user.lastName,
      email: user.email,
      password: user.password,
      role: user.role,
      linkedInToken: user.linkedInToken,
      createdAt: user.createdAt ? user.createdAt.toISOString() : null,
      updatedAt: user.updatedAt ? user.updatedAt.toISOString() : null,
    };
  }

  // üîπ Deserializaci√≥n: Convierte una fila de la DB a objeto de la aplicaci√≥n
  private deserialize(row: any) {
    return {
      id: row.id,
      companyId: row.company_id,
      firstName: row.first_name,
      lastName: row.last_name,
      email: row.email,
      password: row.password,
      role: row.role,
      linkedInToken: row.linkedin_token,
      createdAt: row.created_at ? new Date(row.created_at) : null,
      updatedAt: row.updated_at ? new Date(row.updated_at) : null,
    };
  }

  // üîπ Obtener todos los usuarios
  async getAllUsers() {
    const query = "SELECT * FROM users";
    const { rows } = await db.query(query);
    return rows.map(this.deserialize);  // Usamos deserializaci√≥n para convertir filas
  }

  // üîπ Obtener un usuario por ID
  async getUserById(id: string) {
    const query = "SELECT * FROM users WHERE id = $1";
    const { rows } = await db.query(query, [id]);
    return rows.length > 0 ? this.deserialize(rows[0]) : null;
  }

  // üîπ Obtener un usuario por correo electr√≥nico
  async getUserByEmail(email: string) {
    const query = "SELECT * FROM users WHERE email = $1";
    const { rows } = await db.query(query, [email]);
    return rows.length > 0 ? this.deserialize(rows[0]) : null;
  }

  // üîπ Crear un nuevo usuario
  async createUser(user: any) {
      try {
          console.log("üìå Insertando usuario en la base de datos:", user);
          
          const query = `INSERT INTO users (id, first_name, last_name, email, password, role, created_at) 
                        VALUES ($1, $2, $3, $4, $5, $6, NOW()) RETURNING *`;

          const { rows } = await db.query(query, [
              user.id,
              user.firstName,
              user.lastName,
              user.email,
              user.password,
              user.role,
          ]);

          // Aseg√∫rate de que se retorne correctamente el usuario
          if (rows.length === 0) {
              throw new Error("No se pudo crear el usuario en la base de datos.");
          }

          const createdUser = rows[0];  // Esto deber√≠a dar el primer (y √∫nico) resultado de la inserci√≥n
          console.log("‚úÖ Usuario insertado en la base de datos:", createdUser);

          return createdUser;
      } catch (error) {
          console.error("‚ùå Error en createUser():", error);
          throw error;
      }
  }

  // üîπ Actualizar un usuario
  async updateUser(id: string, user: any) {
    const serializedUser = this.serialize(user);
    const query = `UPDATE users SET 
                   company_id = COALESCE($1, company_id), 
                   first_name = COALESCE($2, first_name), 
                   last_name = COALESCE($3, last_name), 
                   email = COALESCE($4, email), 
                   password = COALESCE($5, password), 
                   role = COALESCE($6, role), 
                   linkedin_token = COALESCE($7, linkedin_token), 
                   updated_at = NOW() 
                   WHERE id = $8 RETURNING *`;
    const { rows } = await db.query(query, [
      serializedUser.companyId,
      serializedUser.firstName,
      serializedUser.lastName,
      serializedUser.email,
      serializedUser.password,
      serializedUser.role,
      serializedUser.linkedInToken,
      id,
    ]);
    return rows[0];  // Devuelve el usuario actualizado
  }

  // üîπ Eliminar un usuario
  async deleteUser(id: string): Promise<void> {
    const query = "DELETE FROM users WHERE id = $1";
    await db.query(query, [id]);
  }

  // üîπ Registrar un nuevo usuario
  async register(user: any) {
    try {
        console.log("üìå Intentando registrar usuario:", user);

        const existingUser = await this.getUserByEmail(user.email);
        if (existingUser) {
            throw new Error('‚ùå El correo electr√≥nico ya est√° registrado');
        }

        const hashedPassword = await bcrypt.hash(user.password, 10);
        console.log("üîë Contrase√±a cifrada:", hashedPassword);

        const newUser = {
            id: uuidv4(),
            ...user,
            password: hashedPassword,
        };

        console.log("üìå Creando usuario en la base de datos:", newUser);

        const createdUser = await this.createUser(newUser);
        console.log("‚úÖ Usuario creado con √©xito:", createdUser);

        return createdUser;
    } catch (error) {
        console.error("‚ùå Error en register():", error);
        throw error;
    }
}



  // üîπ Iniciar sesi√≥n de un usuario
    async login(email: string, password: string) {
      console.log("Intentando iniciar sesi√≥n con email:", email);

      // Verificar si el usuario existe
      const user = await this.getUserByEmail(email);
      if (!user) {
          console.error("‚ùå Usuario no encontrado en la base de datos");
          throw new Error('Usuario no encontrado');
      }

      console.log("‚úÖ Usuario encontrado:", user);

      // Verificar la contrase√±a
      const isPasswordValid = await bcrypt.compare(password, user.password);
      console.log("Resultado de la comparaci√≥n de contrase√±a:", isPasswordValid);

      if (!isPasswordValid) {
          console.error("‚ùå Contrase√±a incorrecta");
          throw new Error('Contrase√±a incorrecta');
      }

      console.log("‚úÖ Contrase√±a correcta, generando token...");

      // Crear un JWT para el usuario
      const token = this.generateAuthToken(user);
      console.log("‚úÖ Token generado:", token);

      return { user, token };
  }


  // üîπ Generar un token de autenticaci√≥n (JWT)
  private generateAuthToken(user: any) {
    const payload = {
      id: user.id,
      email: user.email,
      role: user.role,
    };
  
    const secretKey: string = process.env.SECRET_KEY || 'default-secret-key'; // Si no se encuentra, usar un valor por defecto
  
    // Definir expl√≠citamente las opciones con el tipo `SignOptions`
    const options: SignOptions = {
      expiresIn: '1h', // Esto deber√≠a ser reconocido correctamente
    };
  
    // La firma del JWT
    return jwt.sign(payload, secretKey, options);
  }
}

// Exportamos la instancia del controlador
export const userController = new UserController();
